// AFOCE - Adaptive Financial Operations & Compliance Engine
// Database Schema - Using PostgreSQL with Prisma ORM

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & BUSINESS PROFILE
// ============================================

model User {
  id           String  @id @default(uuid())
  email        String  @unique
  password     String // bcrypt hashed
  businessName String
  panNumber    String? // Permanent Account Number
  vatNumber    String? // VAT Registration Number
  address      String?
  phone        String?
  logoUrl      String?
  settings     Json    @default("{}")
  language     String  @default("en") // "en" | "ne"

  // Password reset
  resetToken       String? // Hashed reset token
  resetTokenExpiry DateTime? // Token expiry time

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  invoices         Invoice[]
  expenses         Expense[]
  customers        Customer[]
  vendors          Vendor[]
  accounts         Account[]
  bankAccounts     BankAccount[]
  vatRecords       VatRecord[]
  roles            UserRole[]
  businessRules    BusinessRule[]
  auditLogs        AuditLog[]
  workflowActions  WorkflowHistory[] @relation("WorkflowActor")
  notifications    Notification[]
  approvedInvoices Invoice[]         @relation("InvoiceApprover")
  rejectedInvoices Invoice[]         @relation("InvoiceRejector")
  approvedExpenses Expense[]         @relation("ExpenseApprover")
  rejectedExpenses Expense[]         @relation("ExpenseRejector")
}

// ============================================
// RBAC - ROLE BASED ACCESS CONTROL
// ============================================

enum RoleType {
  OWNER // Full access
  MANAGER // Approve/reject, view all, create/edit
  ACCOUNTANT // Create/edit, view all, no approve
  VIEWER // Read-only access
}

model UserRole {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  roleType  RoleType
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A user can have multiple roles (e.g., OWNER + ACCOUNTANT)
  @@unique([userId, roleType])
  @@index([userId])
}

// Permission matrix (hardcoded in application logic)
// OWNER: ALL permissions
// MANAGER: invoices.*, expenses.*, customers.*, vendors.*, approve, reject
// ACCOUNTANT: invoices.create, invoices.edit, expenses.*, customers.*, vendors.*
// VIEWER: *.read

// ============================================
// CHART OF ACCOUNTS
// ============================================

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  INCOME
  EXPENSE
}

model Account {
  id          String      @id @default(uuid())
  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  code        String // Account code e.g., "1000", "2000"
  name        String // English name
  nameNe      String? // Nepali name (Devanagari)
  type        AccountType
  description String?
  parentId    String?
  parent      Account?    @relation("AccountHierarchy", fields: [parentId], references: [id])
  children    Account[]   @relation("AccountHierarchy")
  isSystem    Boolean     @default(false) // System accounts can't be deleted
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  invoiceItems InvoiceItem[]
  expenses     Expense[]

  @@unique([userId, code])
  @@index([userId, type])
}

// ============================================
// CUSTOMERS & VENDORS
// ============================================

model Customer {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  email     String?
  phone     String?
  panNumber String? // Customer's PAN for VAT invoices
  address   String?
  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  invoices Invoice[]

  @@index([userId])
}

model Vendor {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  email     String?
  phone     String?
  panNumber String? // Vendor's PAN for VAT claims
  address   String?
  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  expenses Expense[]

  @@index([userId])
}

// ============================================
// INVOICING & SALES
// ============================================

enum InvoiceStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REJECTED
  SENT
  PARTIALLY_PAID
  PAID
  OVERDUE
  COLLECTION
  WRITTEN_OFF
  CANCELLED
}

model Invoice {
  id             String        @id @default(uuid())
  userId         String
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoiceNumber  String // Sequential: INV-2080-0001
  customerId     String
  customer       Customer      @relation(fields: [customerId], references: [id])
  issueDate      DateTime
  dueDate        DateTime
  status         InvoiceStatus @default(DRAFT)
  subtotal       Decimal       @db.Decimal(15, 2) // Before VAT
  vatRate        Decimal       @default(13.00) @db.Decimal(5, 2) // Nepal VAT rate
  vatAmount      Decimal       @db.Decimal(15, 2)
  discountAmount Decimal       @default(0) @db.Decimal(15, 2)
  total          Decimal       @db.Decimal(15, 2) // Final amount
  paidAmount     Decimal       @default(0) @db.Decimal(15, 2)
  notes          String?
  terms          String?
  pdfUrl         String?
  syncStatus     String        @default("synced") // "synced" | "pending" | "error"
  localId        String? // For offline-first sync

  // Workflow fields
  requiresApproval Boolean   @default(false)
  approvedBy       String?
  approver         User?     @relation("InvoiceApprover", fields: [approvedBy], references: [id])
  approvedAt       DateTime?
  rejectedBy       String?
  rejector         User?     @relation("InvoiceRejector", fields: [rejectedBy], references: [id])
  rejectedAt       DateTime?
  rejectionReason  String?   @db.Text

  // Workflow state metadata (JSON for flexibility)
  workflowState Json? // { currentState, nextPossibleActions, assignedTo, deadline, metadata }

  // Optimistic locking for concurrent updates
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  items           InvoiceItem[]
  transactions    BankTransaction[]
  workflowHistory WorkflowHistory[]
  notifications   Notification[]
  payments        Payment[]

  @@unique([userId, invoiceNumber])
  @@index([userId, status])
  @@index([userId, issueDate])
  @@index([status, dueDate]) // For automated overdue detection
  @@index([requiresApproval, status]) // For approval queue queries
}

model InvoiceItem {
  id          String  @id @default(uuid())
  invoiceId   String
  invoice     Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  accountId   String
  account     Account @relation(fields: [accountId], references: [id])
  description String
  quantity    Decimal @db.Decimal(10, 2)
  rate        Decimal @db.Decimal(15, 2)
  amount      Decimal @db.Decimal(15, 2) // quantity * rate
  sortOrder   Int     @default(0)

  @@index([invoiceId])
}

// ============================================
// EXPENSE TRACKING
// ============================================

enum ExpenseStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REJECTED
  PAID
  CANCELLED
}

model Expense {
  id            String        @id @default(uuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  expenseNumber String // Sequential: EXP-2080-0001
  vendorId      String?
  vendor        Vendor?       @relation(fields: [vendorId], references: [id])
  accountId     String
  account       Account       @relation(fields: [accountId], references: [id])
  date          DateTime
  description   String
  amount        Decimal       @db.Decimal(15, 2)
  vatRate       Decimal       @default(13.00) @db.Decimal(5, 2)
  vatAmount     Decimal       @default(0) @db.Decimal(15, 2)
  totalAmount   Decimal       @db.Decimal(15, 2)
  receiptUrl    String? // Uploaded receipt image
  notes         String?
  status        ExpenseStatus @default(DRAFT)
  isPaid        Boolean       @default(true)
  syncStatus    String        @default("synced")
  localId       String?

  // Workflow fields
  requiresApproval Boolean   @default(false)
  approvedBy       String?
  approver         User?     @relation("ExpenseApprover", fields: [approvedBy], references: [id])
  approvedAt       DateTime?
  rejectedBy       String?
  rejector         User?     @relation("ExpenseRejector", fields: [rejectedBy], references: [id])
  rejectedAt       DateTime?
  rejectionReason  String?   @db.Text

  // Policy violations (JSON array of rule violations)
  policyViolations Json? // [{ ruleId, ruleName, severity, message }]

  // Workflow state
  workflowState Json?

  // Optimistic locking
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions    BankTransaction[]
  workflowHistory WorkflowHistory[]
  notifications   Notification[]

  @@unique([userId, expenseNumber])
  @@index([userId, date])
  @@index([userId, accountId])
  @@index([userId, status])
  @@index([requiresApproval, status])
}

// ============================================
// VAT MANAGEMENT
// ============================================

enum VatRecordStatus {
  PENDING
  FILED
  PAID
}

model VatRecord {
  id            String          @id @default(uuid())
  userId        String
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  periodStart   DateTime // Fiscal month start
  periodEnd     DateTime // Fiscal month end
  periodLabel   String // "2080-01" (BS format)
  salesVat      Decimal         @db.Decimal(15, 2) // VAT collected from sales
  purchaseVat   Decimal         @db.Decimal(15, 2) // VAT paid on purchases
  netVat        Decimal         @db.Decimal(15, 2) // salesVat - purchaseVat
  status        VatRecordStatus @default(PENDING)
  filedDate     DateTime?
  notes         String?
  irdReportJson Json? // IRD-format export data
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@unique([userId, periodLabel])
  @@index([userId, status])
}

// ============================================
// PAYMENT GATEWAY INTEGRATION
// ============================================

enum PaymentProvider {
  ESEWA
  KHALTI
  BANK_TRANSFER
  CASH
  CHEQUE
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

model Payment {
  id            String          @id @default(uuid())
  transactionId String          @unique // Our transaction reference
  invoiceId     String
  invoice       Invoice         @relation(fields: [invoiceId], references: [id])
  amount        Decimal         @db.Decimal(15, 2)
  provider      PaymentProvider
  status        PaymentStatus   @default(PENDING)
  khaltiPidx    String? // Khalti payment index
  metadata      Json? // Provider-specific data
  rawResponse   Json? // Full response from gateway
  completedAt   DateTime?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([invoiceId])
  @@index([status])
  @@index([transactionId])
}

// ============================================
// MULTI-COMPANY SUPPORT (Phase 4)
// ============================================

model Company {
  id              String   @id @default(uuid())
  name            String
  nameNe          String? // Nepali name
  panNumber       String?
  vatNumber       String?
  address         String?
  phone           String?
  email           String?
  logoUrl         String?
  fiscalYearStart Int      @default(4) // Month (1-12), Nepal starts in Shrawan (July = 4th month in Gregorian mapping)
  currency        String   @default("NPR")
  vatRate         Decimal  @default(13.00) @db.Decimal(5, 2)
  settings        Json     @default("{}")
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  members CompanyMember[]

  @@index([isActive])
}

model CompanyMember {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId    String
  role      RoleType @default(VIEWER)
  isDefault Boolean  @default(false) // Default company for user
  isActive  Boolean  @default(true) // Soft delete for members
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, userId])
  @@index([userId])
  @@index([isActive])
}

// ============================================
// BANK RECONCILIATION
// ============================================

model BankAccount {
  id             String   @id @default(uuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name           String // e.g., "Main Business Account"
  bankName       String?
  accountNumber  String?
  openingBalance Decimal  @default(0) @db.Decimal(15, 2)
  currentBalance Decimal  @default(0) @db.Decimal(15, 2)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  transactions BankTransaction[]

  @@index([userId])
}

model BankTransaction {
  id            String      @id @default(uuid())
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  date          DateTime
  description   String
  amount        Decimal     @db.Decimal(15, 2)
  type          String // "debit" | "credit"
  reconciled    Boolean     @default(false)
  reconciledAt  DateTime?
  invoiceId     String? // Matched invoice
  invoice       Invoice?    @relation(fields: [invoiceId], references: [id])
  expenseId     String? // Matched expense
  expense       Expense?    @relation(fields: [expenseId], references: [id])
  notes         String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([bankAccountId, reconciled])
  @@index([bankAccountId, date])
}

// ============================================
// OFFLINE SYNC QUEUE
// ============================================

model SyncQueue {
  id         String   @id @default(uuid())
  userId     String
  entityType String // "invoice" | "expense" | "customer" | "vendor"
  entityId   String // Local ID
  action     String // "create" | "update" | "delete"
  payload    Json // Entity data
  attempts   Int      @default(0)
  lastError  String?
  status     String   @default("pending") // "pending" | "processing" | "completed" | "failed"
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId, status])
}

// ============================================
// WORKFLOW ENGINE
// ============================================

enum EntityType {
  INVOICE
  EXPENSE
  CUSTOMER
  VENDOR
  PAYMENT
}

// Workflow History - Immutable audit trail of state transitions
model WorkflowHistory {
  id         String     @id @default(uuid())
  entityType EntityType
  entityId   String

  // State transition
  fromState String
  toState   String

  // Actor information
  actorId   String
  actor     User    @relation("WorkflowActor", fields: [actorId], references: [id])
  actorRole String? // Role at time of action (for historical accuracy)
  ipAddress String?
  userAgent String?

  // Reason and metadata
  reason   String? @db.Text
  metadata Json? // Additional context: { approvalLevel, comments, attachments }

  // Timestamp - immutable
  timestamp DateTime @default(now())

  // Relations for easy querying
  invoice Invoice? @relation(fields: [entityId], references: [id], map: "workflow_invoice_fk")
  expense Expense? @relation(fields: [entityId], references: [id], map: "workflow_expense_fk")

  @@index([entityType, entityId, timestamp])
  @@index([actorId, timestamp])
  @@index([timestamp]) // For time-series queries
  @@map("workflow_history")
}

// ============================================
// BUSINESS RULE ENGINE
// ============================================

enum RuleType {
  APPROVAL // Requires approval routing
  VALIDATION // Block/warn on condition violation
  COMPLIANCE // Regulatory compliance checks
  NOTIFICATION // Trigger notifications
  AUTOMATION // Automated actions
}

enum RuleAction {
  REQUIRE_APPROVAL
  REQUIRE_ATTACHMENT
  BLOCK_CREATION
  SHOW_WARNING
  SEND_NOTIFICATION
  AUTO_ASSIGN
  CALCULATE_FIELD
}

enum RuleSeverity {
  CRITICAL // Must comply, blocks action
  WARNING // Shows warning, allows override
  INFO // Informational only
}

model BusinessRule {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Rule metadata
  name        String
  description String?    @db.Text
  ruleType    RuleType
  entityType  EntityType

  // Condition (Abstract Syntax Tree for complex conditions)
  // Example: { operator: "AND", children: [
  //   { field: "total", operator: "gt", value: 50000 },
  //   { field: "customer.type", operator: "eq", value: "ENTERPRISE" }
  // ]}
  condition Json

  // Action configuration
  action       RuleAction
  actionParams Json? // Parameters for action (e.g., { approverRole: "MANAGER", notifyEmail: "..." })

  // Priority and control
  enabled  Boolean      @default(true)
  priority Int          @default(0) // Higher priority rules evaluated first
  severity RuleSeverity @default(WARNING)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID who created the rule

  // Execution statistics
  executionCount Int @default(0) // How many times this rule was evaluated
  triggerCount   Int @default(0) // How many times it triggered an action

  @@index([userId, enabled, priority])
  @@index([entityType, enabled])
  @@map("business_rules")
}

// ============================================
// AUDIT LOG - IMMUTABLE
// ============================================

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  REJECT
  SEND
  PAY
  CANCEL
  LOGIN
  LOGOUT
  SETTINGS_CHANGE
  RULE_CREATE
  RULE_UPDATE
  RULE_DELETE
}

model AuditLog {
  id String @id @default(uuid())

  // Timestamp - primary key for time-series
  timestamp DateTime @default(now())

  // Actor
  actorId    String
  actor      User    @relation(fields: [actorId], references: [id])
  actorEmail String // Denormalized for historical accuracy
  actorRole  String? // Role at time of action
  ipAddress  String?
  userAgent  String?

  // Action
  action     AuditAction
  entityType EntityType?
  entityId   String?

  // Changes (for UPDATE actions)
  // Format: { old: { field: value }, new: { field: value } }
  changes Json?

  // Additional metadata
  metadata Json? // Request payload, response, etc.

  // Security
  checksum String? // SHA-256 hash for tamper detection

  @@index([timestamp]) // Time-series primary access pattern
  @@index([actorId, timestamp])
  @@index([entityType, entityId])
  @@index([action, timestamp])
  @@map("audit_logs")
}

// ============================================
// NOTIFICATION SYSTEM
// ============================================

enum NotificationType {
  APPROVAL_REQUIRED
  INVOICE_APPROVED
  INVOICE_REJECTED
  EXPENSE_APPROVED
  EXPENSE_REJECTED
  PAYMENT_RECEIVED
  INVOICE_OVERDUE
  BUDGET_THRESHOLD
  POLICY_VIOLATION
  SYSTEM_ALERT
}

enum NotificationStatus {
  PENDING
  SENT
  READ
  FAILED
}

enum NotificationChannel {
  IN_APP
  EMAIL
  SMS
  WEBHOOK
}

model Notification {
  id String @id @default(uuid())

  // Recipient
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Notification details
  type    NotificationType
  channel NotificationChannel
  status  NotificationStatus  @default(PENDING)

  // Content
  title   String
  message String @db.Text
  data    Json? // Structured data for in-app rendering

  // Related entities
  entityType EntityType?
  entityId   String?
  invoice    Invoice?    @relation(fields: [entityId], references: [id], map: "notification_invoice_fk")
  expense    Expense?    @relation(fields: [entityId], references: [id], map: "notification_expense_fk")

  // Actions
  actionUrl String? // Deep link to entity
  actions   Json? // [{ label: "Approve", action: "approve", url: "..." }]

  // Delivery tracking
  sentAt       DateTime?
  readAt       DateTime?
  failedAt     DateTime?
  errorMessage String?
  retryCount   Int       @default(0)

  // Timestamps
  createdAt DateTime  @default(now())
  expiresAt DateTime? // Auto-delete after expiry

  @@index([userId, status, createdAt])
  @@index([status, createdAt]) // For processing queue
  @@index([type, status])
  @@map("notifications")
}

// ============================================
// BACKGROUND JOBS (BullMQ metadata)
// ============================================

model JobQueue {
  id String @id @default(uuid())

  // Job identification
  jobId     String @unique // BullMQ job ID
  queueName String // "notifications", "reports", "reminders"
  jobType   String // Specific job type

  // Job data
  payload Json

  // Status
  status   String @default("pending") // pending, active, completed, failed
  progress Int    @default(0) // 0-100

  // Execution
  attempts    Int     @default(0)
  maxAttempts Int     @default(3)
  lastError   String? @db.Text

  // Timestamps
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  failedAt    DateTime?

  // Scheduling
  scheduledFor DateTime? // For delayed jobs

  @@index([status, scheduledFor])
  @@index([queueName, status])
  @@map("job_queue")
}

// ============================================
// INVENTORY MANAGEMENT
// ============================================

model Product {
  id     String @id @default(uuid())
  userId String

  // Product Info
  name        String
  nameNe      String? // Nepali name
  sku         String // Stock Keeping Unit
  description String?
  category    String?

  // Pricing
  costPrice    Decimal @default(0) @db.Decimal(15, 2)
  sellingPrice Decimal @default(0) @db.Decimal(15, 2)

  // Tax
  vatRate     Decimal @default(13.00) @db.Decimal(5, 2)
  isVatExempt Boolean @default(false)

  // Stock
  currentStock    Int    @default(0)
  reorderLevel    Int    @default(10)
  reorderQuantity Int    @default(50)
  unit            String @default("pcs") // pcs, kg, ltr, etc.

  // Status
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  stockMovements StockMovement[]

  @@unique([userId, sku])
  @@index([userId, category])
  @@index([userId, isActive])
  @@map("products")
}

enum StockMovementType {
  PURCHASE // Stock in from purchase
  SALE // Stock out from sale
  ADJUSTMENT // Manual adjustment
  RETURN_IN // Customer return
  RETURN_OUT // Return to supplier
  DAMAGED // Damaged goods
  TRANSFER // Transfer between locations
}

model StockMovement {
  id        String  @id @default(uuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  type     StockMovementType
  quantity Int // Positive for in, negative for out

  // Reference
  referenceType String? // "invoice", "expense", "adjustment"
  referenceId   String?

  // Details
  notes    String?
  unitCost Decimal? @db.Decimal(15, 2)

  // Balance tracking
  previousStock Int
  newStock      Int

  createdAt DateTime @default(now())
  createdBy String? // User who made the change

  @@index([productId, createdAt])
  @@index([type])
  @@map("stock_movements")
}

// ============================================
// PROJECT TRACKING
// ============================================

enum ProjectStatus {
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

model Project {
  id     String @id @default(uuid())
  userId String

  // Project Info
  name        String
  nameNe      String? // Nepali name
  code        String // Unique project code
  description String?

  // Client/Customer
  customerId String?

  // Financial
  budget   Decimal? @db.Decimal(15, 2)
  currency String   @default("NPR")

  // Timeline
  startDate DateTime?
  endDate   DateTime?

  // Status
  status ProjectStatus @default(ACTIVE)

  // Billing
  billable    Boolean  @default(true)
  billingRate Decimal? @db.Decimal(15, 2) // Hourly/daily rate
  billingType String? // "hourly", "fixed", "milestone"

  // Tags and Categories
  category String?
  tags     String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  entries ProjectEntry[]

  @@unique([userId, code])
  @@index([userId, status])
  @@index([userId, customerId])
  @@map("projects")
}

enum ProjectEntryType {
  REVENUE // Income from project
  EXPENSE // Cost incurred
  TIME // Time log entry
  MILESTONE // Project milestone
}

model ProjectEntry {
  id        String  @id @default(uuid())
  projectId String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  type ProjectEntryType

  // Description
  description String
  notes       String?

  // Financial (for revenue/expense)
  amount Decimal? @db.Decimal(15, 2)

  // Time tracking
  hours Decimal? @db.Decimal(8, 2)
  date  DateTime @default(now())

  // Reference to actual invoice/expense
  invoiceId String?
  expenseId String?

  // Metadata
  isBillable Boolean @default(true)
  isBilled   Boolean @default(false)

  createdAt DateTime @default(now())
  createdBy String?

  @@index([projectId, type])
  @@index([projectId, date])
  @@map("project_entries")
}

// ============================================
// MULTI-CURRENCY SUPPORT
// ============================================

// Exchange rates for currency conversions
model ExchangeRate {
  id            String   @id @default(uuid())
  fromCurrency  String // e.g., "USD"
  toCurrency    String // e.g., "NPR"
  rate          Decimal  @db.Decimal(15, 6)
  effectiveDate DateTime @default(now())
  source        String? // e.g., "manual", "api", "nepal_rastra_bank"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fromCurrency, toCurrency, effectiveDate])
  @@index([fromCurrency, toCurrency])
  @@index([effectiveDate])
  @@map("exchange_rates")
}

// Currency configuration (supported currencies)
model Currency {
  id       String  @id @default(uuid())
  code     String  @unique // ISO code: USD, NPR, INR, EUR
  name     String // Full name
  nameNe   String? // Nepali name
  symbol   String // $, रु, ₹, €
  decimals Int     @default(2)
  isActive Boolean @default(true)
  isBase   Boolean @default(false) // Base currency (NPR for Nepal)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("currencies")
}
