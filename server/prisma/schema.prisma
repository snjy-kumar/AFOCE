// AFOCE - Adaptive Financial Operations & Compliance Engine
// Database Schema - Using PostgreSQL with Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & BUSINESS PROFILE
// ============================================

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  password     String // bcrypt hashed
  businessName String
  panNumber    String? // Permanent Account Number
  vatNumber    String? // VAT Registration Number
  address      String?
  phone        String?
  logoUrl      String?
  settings     Json     @default("{}")
  language     String   @default("en") // "en" | "ne"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  invoices         Invoice[]
  expenses         Expense[]
  customers        Customer[]
  vendors          Vendor[]
  accounts         Account[]
  bankAccounts     BankAccount[]
  vatRecords       VatRecord[]
  roles            UserRole[]
  businessRules    BusinessRule[]
  auditLogs        AuditLog[]
  workflowActions  WorkflowHistory[] @relation("WorkflowActor")
  notifications    Notification[]
  approvedInvoices Invoice[]         @relation("InvoiceApprover")
  rejectedInvoices Invoice[]         @relation("InvoiceRejector")
  approvedExpenses Expense[]         @relation("ExpenseApprover")
  rejectedExpenses Expense[]         @relation("ExpenseRejector")
}

// ============================================
// RBAC - ROLE BASED ACCESS CONTROL
// ============================================

enum RoleType {
  OWNER // Full access
  MANAGER // Approve/reject, view all, create/edit
  ACCOUNTANT // Create/edit, view all, no approve
  VIEWER // Read-only access
}

model UserRole {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  roleType  RoleType
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A user can have multiple roles (e.g., OWNER + ACCOUNTANT)
  @@unique([userId, roleType])
  @@index([userId])
}

// Permission matrix (hardcoded in application logic)
// OWNER: ALL permissions
// MANAGER: invoices.*, expenses.*, customers.*, vendors.*, approve, reject
// ACCOUNTANT: invoices.create, invoices.edit, expenses.*, customers.*, vendors.*
// VIEWER: *.read

// ============================================
// CHART OF ACCOUNTS
// ============================================

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  INCOME
  EXPENSE
}

model Account {
  id          String      @id @default(uuid())
  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  code        String // Account code e.g., "1000", "2000"
  name        String // English name
  nameNe      String? // Nepali name (Devanagari)
  type        AccountType
  description String?
  parentId    String?
  parent      Account?    @relation("AccountHierarchy", fields: [parentId], references: [id])
  children    Account[]   @relation("AccountHierarchy")
  isSystem    Boolean     @default(false) // System accounts can't be deleted
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  invoiceItems InvoiceItem[]
  expenses     Expense[]

  @@unique([userId, code])
  @@index([userId, type])
}

// ============================================
// CUSTOMERS & VENDORS
// ============================================

model Customer {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  email     String?
  phone     String?
  panNumber String? // Customer's PAN for VAT invoices
  address   String?
  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  invoices Invoice[]

  @@index([userId])
}

model Vendor {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  email     String?
  phone     String?
  panNumber String? // Vendor's PAN for VAT claims
  address   String?
  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  expenses Expense[]

  @@index([userId])
}

// ============================================
// INVOICING & SALES
// ============================================

enum InvoiceStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REJECTED
  SENT
  PARTIALLY_PAID
  PAID
  OVERDUE
  COLLECTION
  WRITTEN_OFF
  CANCELLED
}

model Invoice {
  id             String        @id @default(uuid())
  userId         String
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoiceNumber  String // Sequential: INV-2080-0001
  customerId     String
  customer       Customer      @relation(fields: [customerId], references: [id])
  issueDate      DateTime
  dueDate        DateTime
  status         InvoiceStatus @default(DRAFT)
  subtotal       Decimal       @db.Decimal(15, 2) // Before VAT
  vatRate        Decimal       @default(13.00) @db.Decimal(5, 2) // Nepal VAT rate
  vatAmount      Decimal       @db.Decimal(15, 2)
  discountAmount Decimal       @default(0) @db.Decimal(15, 2)
  total          Decimal       @db.Decimal(15, 2) // Final amount
  paidAmount     Decimal       @default(0) @db.Decimal(15, 2)
  notes          String?
  terms          String?
  pdfUrl         String?
  syncStatus     String        @default("synced") // "synced" | "pending" | "error"
  localId        String? // For offline-first sync

  // Workflow fields
  requiresApproval Boolean   @default(false)
  approvedBy       String?
  approver         User?     @relation("InvoiceApprover", fields: [approvedBy], references: [id])
  approvedAt       DateTime?
  rejectedBy       String?
  rejector         User?     @relation("InvoiceRejector", fields: [rejectedBy], references: [id])
  rejectedAt       DateTime?
  rejectionReason  String?   @db.Text

  // Workflow state metadata (JSON for flexibility)
  workflowState Json? // { currentState, nextPossibleActions, assignedTo, deadline, metadata }

  // Optimistic locking for concurrent updates
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  items           InvoiceItem[]
  transactions    BankTransaction[]
  workflowHistory WorkflowHistory[]
  notifications   Notification[]

  @@unique([userId, invoiceNumber])
  @@index([userId, status])
  @@index([userId, issueDate])
  @@index([status, dueDate]) // For automated overdue detection
  @@index([requiresApproval, status]) // For approval queue queries
}

model InvoiceItem {
  id          String  @id @default(uuid())
  invoiceId   String
  invoice     Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  accountId   String
  account     Account @relation(fields: [accountId], references: [id])
  description String
  quantity    Decimal @db.Decimal(10, 2)
  rate        Decimal @db.Decimal(15, 2)
  amount      Decimal @db.Decimal(15, 2) // quantity * rate
  sortOrder   Int     @default(0)

  @@index([invoiceId])
}

// ============================================
// EXPENSE TRACKING
// ============================================

enum ExpenseStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REJECTED
  PAID
  CANCELLED
}

model Expense {
  id            String        @id @default(uuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  expenseNumber String // Sequential: EXP-2080-0001
  vendorId      String?
  vendor        Vendor?       @relation(fields: [vendorId], references: [id])
  accountId     String
  account       Account       @relation(fields: [accountId], references: [id])
  date          DateTime
  description   String
  amount        Decimal       @db.Decimal(15, 2)
  vatRate       Decimal       @default(13.00) @db.Decimal(5, 2)
  vatAmount     Decimal       @default(0) @db.Decimal(15, 2)
  totalAmount   Decimal       @db.Decimal(15, 2)
  receiptUrl    String? // Uploaded receipt image
  notes         String?
  status        ExpenseStatus @default(DRAFT)
  isPaid        Boolean       @default(true)
  syncStatus    String        @default("synced")
  localId       String?

  // Workflow fields
  requiresApproval Boolean   @default(false)
  approvedBy       String?
  approver         User?     @relation("ExpenseApprover", fields: [approvedBy], references: [id])
  approvedAt       DateTime?
  rejectedBy       String?
  rejector         User?     @relation("ExpenseRejector", fields: [rejectedBy], references: [id])
  rejectedAt       DateTime?
  rejectionReason  String?   @db.Text

  // Policy violations (JSON array of rule violations)
  policyViolations Json? // [{ ruleId, ruleName, severity, message }]

  // Workflow state
  workflowState Json?

  // Optimistic locking
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions    BankTransaction[]
  workflowHistory WorkflowHistory[]
  notifications   Notification[]

  @@unique([userId, expenseNumber])
  @@index([userId, date])
  @@index([userId, accountId])
  @@index([userId, status])
  @@index([requiresApproval, status])
}

// ============================================
// VAT MANAGEMENT
// ============================================

enum VatRecordStatus {
  PENDING
  FILED
  PAID
}

model VatRecord {
  id            String          @id @default(uuid())
  userId        String
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  periodStart   DateTime // Fiscal month start
  periodEnd     DateTime // Fiscal month end
  periodLabel   String // "2080-01" (BS format)
  salesVat      Decimal         @db.Decimal(15, 2) // VAT collected from sales
  purchaseVat   Decimal         @db.Decimal(15, 2) // VAT paid on purchases
  netVat        Decimal         @db.Decimal(15, 2) // salesVat - purchaseVat
  status        VatRecordStatus @default(PENDING)
  filedDate     DateTime?
  notes         String?
  irdReportJson Json? // IRD-format export data
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@unique([userId, periodLabel])
  @@index([userId, status])
}

// ============================================
// BANK RECONCILIATION
// ============================================

model BankAccount {
  id             String   @id @default(uuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name           String // e.g., "Main Business Account"
  bankName       String?
  accountNumber  String?
  openingBalance Decimal  @default(0) @db.Decimal(15, 2)
  currentBalance Decimal  @default(0) @db.Decimal(15, 2)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  transactions BankTransaction[]

  @@index([userId])
}

model BankTransaction {
  id            String      @id @default(uuid())
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  date          DateTime
  description   String
  amount        Decimal     @db.Decimal(15, 2)
  type          String // "debit" | "credit"
  reconciled    Boolean     @default(false)
  reconciledAt  DateTime?
  invoiceId     String? // Matched invoice
  invoice       Invoice?    @relation(fields: [invoiceId], references: [id])
  expenseId     String? // Matched expense
  expense       Expense?    @relation(fields: [expenseId], references: [id])
  notes         String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([bankAccountId, reconciled])
  @@index([bankAccountId, date])
}

// ============================================
// OFFLINE SYNC QUEUE
// ============================================

model SyncQueue {
  id         String   @id @default(uuid())
  userId     String
  entityType String // "invoice" | "expense" | "customer" | "vendor"
  entityId   String // Local ID
  action     String // "create" | "update" | "delete"
  payload    Json // Entity data
  attempts   Int      @default(0)
  lastError  String?
  status     String   @default("pending") // "pending" | "processing" | "completed" | "failed"
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId, status])
}

// ============================================
// WORKFLOW ENGINE
// ============================================

enum EntityType {
  INVOICE
  EXPENSE
  CUSTOMER
  VENDOR
  PAYMENT
}

// Workflow History - Immutable audit trail of state transitions
model WorkflowHistory {
  id         String     @id @default(uuid())
  entityType EntityType
  entityId   String

  // State transition
  fromState String
  toState   String

  // Actor information
  actorId   String
  actor     User    @relation("WorkflowActor", fields: [actorId], references: [id])
  actorRole String? // Role at time of action (for historical accuracy)
  ipAddress String?
  userAgent String?

  // Reason and metadata
  reason   String? @db.Text
  metadata Json? // Additional context: { approvalLevel, comments, attachments }

  // Timestamp - immutable
  timestamp DateTime @default(now())

  // Relations for easy querying
  invoice Invoice? @relation(fields: [entityId], references: [id], map: "workflow_invoice_fk")
  expense Expense? @relation(fields: [entityId], references: [id], map: "workflow_expense_fk")

  @@index([entityType, entityId, timestamp])
  @@index([actorId, timestamp])
  @@index([timestamp]) // For time-series queries
  @@map("workflow_history")
}

// ============================================
// BUSINESS RULE ENGINE
// ============================================

enum RuleType {
  APPROVAL // Requires approval routing
  VALIDATION // Block/warn on condition violation
  COMPLIANCE // Regulatory compliance checks
  NOTIFICATION // Trigger notifications
  AUTOMATION // Automated actions
}

enum RuleAction {
  REQUIRE_APPROVAL
  REQUIRE_ATTACHMENT
  BLOCK_CREATION
  SHOW_WARNING
  SEND_NOTIFICATION
  AUTO_ASSIGN
  CALCULATE_FIELD
}

enum RuleSeverity {
  CRITICAL // Must comply, blocks action
  WARNING // Shows warning, allows override
  INFO // Informational only
}

model BusinessRule {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Rule metadata
  name        String
  description String?    @db.Text
  ruleType    RuleType
  entityType  EntityType

  // Condition (Abstract Syntax Tree for complex conditions)
  // Example: { operator: "AND", children: [
  //   { field: "total", operator: "gt", value: 50000 },
  //   { field: "customer.type", operator: "eq", value: "ENTERPRISE" }
  // ]}
  condition Json

  // Action configuration
  action       RuleAction
  actionParams Json? // Parameters for action (e.g., { approverRole: "MANAGER", notifyEmail: "..." })

  // Priority and control
  enabled  Boolean      @default(true)
  priority Int          @default(0) // Higher priority rules evaluated first
  severity RuleSeverity @default(WARNING)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // User ID who created the rule

  // Execution statistics
  executionCount Int @default(0) // How many times this rule was evaluated
  triggerCount   Int @default(0) // How many times it triggered an action

  @@index([userId, enabled, priority])
  @@index([entityType, enabled])
  @@map("business_rules")
}

// ============================================
// AUDIT LOG - IMMUTABLE
// ============================================

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  APPROVE
  REJECT
  SEND
  PAY
  CANCEL
  LOGIN
  LOGOUT
  SETTINGS_CHANGE
  RULE_CREATE
  RULE_UPDATE
  RULE_DELETE
}

model AuditLog {
  id String @id @default(uuid())

  // Timestamp - primary key for time-series
  timestamp DateTime @default(now())

  // Actor
  actorId    String
  actor      User    @relation(fields: [actorId], references: [id])
  actorEmail String // Denormalized for historical accuracy
  actorRole  String? // Role at time of action
  ipAddress  String?
  userAgent  String?

  // Action
  action     AuditAction
  entityType EntityType?
  entityId   String?

  // Changes (for UPDATE actions)
  // Format: { old: { field: value }, new: { field: value } }
  changes Json?

  // Additional metadata
  metadata Json? // Request payload, response, etc.

  // Security
  checksum String? // SHA-256 hash for tamper detection

  @@index([timestamp]) // Time-series primary access pattern
  @@index([actorId, timestamp])
  @@index([entityType, entityId])
  @@index([action, timestamp])
  @@map("audit_logs")
}

// ============================================
// NOTIFICATION SYSTEM
// ============================================

enum NotificationType {
  APPROVAL_REQUIRED
  INVOICE_APPROVED
  INVOICE_REJECTED
  EXPENSE_APPROVED
  EXPENSE_REJECTED
  PAYMENT_RECEIVED
  INVOICE_OVERDUE
  BUDGET_THRESHOLD
  POLICY_VIOLATION
  SYSTEM_ALERT
}

enum NotificationStatus {
  PENDING
  SENT
  READ
  FAILED
}

enum NotificationChannel {
  IN_APP
  EMAIL
  SMS
  WEBHOOK
}

model Notification {
  id String @id @default(uuid())

  // Recipient
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Notification details
  type    NotificationType
  channel NotificationChannel
  status  NotificationStatus  @default(PENDING)

  // Content
  title   String
  message String @db.Text
  data    Json? // Structured data for in-app rendering

  // Related entities
  entityType EntityType?
  entityId   String?
  invoice    Invoice?    @relation(fields: [entityId], references: [id], map: "notification_invoice_fk")
  expense    Expense?    @relation(fields: [entityId], references: [id], map: "notification_expense_fk")

  // Actions
  actionUrl String? // Deep link to entity
  actions   Json? // [{ label: "Approve", action: "approve", url: "..." }]

  // Delivery tracking
  sentAt       DateTime?
  readAt       DateTime?
  failedAt     DateTime?
  errorMessage String?
  retryCount   Int       @default(0)

  // Timestamps
  createdAt DateTime  @default(now())
  expiresAt DateTime? // Auto-delete after expiry

  @@index([userId, status, createdAt])
  @@index([status, createdAt]) // For processing queue
  @@index([type, status])
  @@map("notifications")
}

// ============================================
// BACKGROUND JOBS (BullMQ metadata)
// ============================================

model JobQueue {
  id String @id @default(uuid())

  // Job identification
  jobId     String @unique // BullMQ job ID
  queueName String // "notifications", "reports", "reminders"
  jobType   String // Specific job type

  // Job data
  payload Json

  // Status
  status   String @default("pending") // pending, active, completed, failed
  progress Int    @default(0) // 0-100

  // Execution
  attempts    Int     @default(0)
  maxAttempts Int     @default(3)
  lastError   String? @db.Text

  // Timestamps
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  failedAt    DateTime?

  // Scheduling
  scheduledFor DateTime? // For delayed jobs

  @@index([status, scheduledFor])
  @@index([queueName, status])
  @@map("job_queue")
}
