/**
 * AFOCE Immutable Audit Logging System
 * 
 * Enterprise-grade audit trail with:
 * - Append-only immutable logs
 * - Cryptographic checksums for tamper detection
 * - Comprehensive change tracking
 * - Time-series optimized queries
 * - Compliance-ready audit reports
 * - Automatic log retention management
 */

import { createHash } from 'crypto';
import type { AuditAction, EntityType, RoleType } from '../../generated/prisma/client.js';
import type {
  AuditLogEntry,
  ChangeSet,
  AuditQuery,
} from '../../types/workflow.types.js';
import prisma from '../../lib/prisma.js';

// ============================================
// AUDIT LOGGER SERVICE
// ============================================

export class AuditLoggerService {
  /**
   * Log an action with automatic change detection
   */
  async log(params: {
    actorId: string;
    actorEmail: string;
    actorRole?: RoleType;
    action: AuditAction;
    entityType?: EntityType;
    entityId?: string;
    oldData?: Record<string, unknown>;
    newData?: Record<string, unknown>;
    metadata?: Record<string, unknown>;
    ipAddress?: string;
    userAgent?: string;
  }): Promise<void> {
    try {
      // Calculate changes if both old and new data provided
      const changes = params.oldData && params.newData
        ? this.calculateChanges(params.oldData, params.newData)
        : undefined;

      // Create audit log entry
      const entry: AuditLogEntry = {
        id: '', // Will be generated by database
        timestamp: new Date(),
        actorId: params.actorId,
        actorEmail: params.actorEmail,
        actorRole: params.actorRole,
        ipAddress: params.ipAddress,
        userAgent: params.userAgent,
        action: params.action,
        entityType: params.entityType,
        entityId: params.entityId,
        changes,
        metadata: params.metadata,
      };

      // Calculate checksum for tamper detection
      const checksum = this.calculateChecksum(entry);

      // Insert into database (append-only)
      await prisma.auditLog.create({
        data: {
          actorId: params.actorId,
          actorEmail: params.actorEmail,
          actorRole: params.actorRole,
          ipAddress: params.ipAddress,
          userAgent: params.userAgent,
          action: params.action,
          entityType: params.entityType,
          entityId: params.entityId,
          changes: changes as any,
          metadata: params.metadata as any,
          checksum,
        },
      });
    } catch (error) {
      // Audit logging should never break the application
      console.error('Failed to write audit log:', error);
      // Consider sending to external logging service (DataDog, Sentry, etc.)
    }
  }

  /**
   * Log invoice action
   */
  async logInvoiceAction(params: {
    actorId: string;
    actorEmail: string;
    action: AuditAction;
    invoiceId: string;
    oldData?: any;
    newData?: any;
    ipAddress?: string;
    userAgent?: string;
  }): Promise<void> {
    await this.log({
      ...params,
      entityType: 'INVOICE',
      entityId: params.invoiceId,
    });
  }

  /**
   * Log expense action
   */
  async logExpenseAction(params: {
    actorId: string;
    actorEmail: string;
    action: AuditAction;
    expenseId: string;
    oldData?: any;
    newData?: any;
    ipAddress?: string;
    userAgent?: string;
  }): Promise<void> {
    await this.log({
      ...params,
      entityType: 'EXPENSE',
      entityId: params.expenseId,
    });
  }

  /**
   * Query audit logs with filters
   */
  async query(params: AuditQuery): Promise<AuditLogEntry[]> {
    const where: any = {};

    if (params.actorId) {
      where.actorId = params.actorId;
    }

    if (params.entityType) {
      where.entityType = params.entityType;
    }

    if (params.entityId) {
      where.entityId = params.entityId;
    }

    if (params.action) {
      where.action = params.action;
    }

    if (params.startDate || params.endDate) {
      where.timestamp = {};
      if (params.startDate) {
        where.timestamp.gte = params.startDate;
      }
      if (params.endDate) {
        where.timestamp.lte = params.endDate;
      }
    }

    const logs = await prisma.auditLog.findMany({
      where,
      orderBy: {
        timestamp: 'desc',
      },
      take: params.limit || 100,
      skip: params.offset || 0,
      include: {
        actor: {
          select: {
            id: true,
            email: true,
            businessName: true,
          },
        },
      },
    });

    return logs.map(log => ({
      id: log.id,
      timestamp: log.timestamp,
      actorId: log.actorId,
      actorEmail: log.actorEmail,
      actorRole: log.actorRole || undefined,
      ipAddress: log.ipAddress || undefined,
      userAgent: log.userAgent || undefined,
      action: log.action,
      entityType: log.entityType || undefined,
      entityId: log.entityId || undefined,
      changes: log.changes as unknown as ChangeSet | undefined,
      metadata: log.metadata as unknown as Record<string, unknown> | undefined,
      checksum: log.checksum || undefined,
    }));
  }

  /**
   * Get audit trail for specific entity
   */
  async getEntityHistory(
    entityType: EntityType,
    entityId: string
  ): Promise<AuditLogEntry[]> {
    return this.query({
      entityType,
      entityId,
      limit: 1000, // Get full history
    });
  }

  /**
   * Get recent activity for user
   */
  async getUserActivity(
    actorId: string,
    limit: number = 50
  ): Promise<AuditLogEntry[]> {
    return this.query({
      actorId,
      limit,
    });
  }

  /**
   * Verify audit log integrity
   */
  async verifyIntegrity(logId: string): Promise<{
    valid: boolean;
    expectedChecksum: string;
    actualChecksum: string;
  }> {
    const log = await prisma.auditLog.findUnique({
      where: { id: logId },
    });

    if (!log) {
      throw new Error('Audit log not found');
    }

    const entry: AuditLogEntry = {
      id: log.id,
      timestamp: log.timestamp,
      actorId: log.actorId,
      actorEmail: log.actorEmail,
      actorRole: log.actorRole || undefined,
      ipAddress: log.ipAddress || undefined,
      userAgent: log.userAgent || undefined,
      action: log.action,
      entityType: log.entityType || undefined,
      entityId: log.entityId || undefined,
      changes: log.changes as unknown as ChangeSet | undefined,
      metadata: log.metadata as unknown as Record<string, unknown> | undefined,
    };

    const expectedChecksum = this.calculateChecksum(entry);
    const actualChecksum = log.checksum || '';

    return {
      valid: expectedChecksum === actualChecksum,
      expectedChecksum,
      actualChecksum,
    };
  }

  /**
   * Generate compliance report
   */
  async generateComplianceReport(params: {
    startDate: Date;
    endDate: Date;
    entityType?: EntityType;
    actions?: AuditAction[];
  }): Promise<{
    totalLogs: number;
    uniqueActors: number;
    actionBreakdown: Record<string, number>;
    timeline: Array<{ date: string; count: number }>;
    topActors: Array<{ actorId: string; actorEmail: string; count: number }>;
  }> {
    const where: any = {
      timestamp: {
        gte: params.startDate,
        lte: params.endDate,
      },
    };

    if (params.entityType) {
      where.entityType = params.entityType;
    }

    if (params.actions && params.actions.length > 0) {
      where.action = { in: params.actions };
    }

    // Total logs
    const totalLogs = await prisma.auditLog.count({ where });

    // Unique actors
    const uniqueActors = await prisma.auditLog.findMany({
      where,
      select: { actorId: true },
      distinct: ['actorId'],
    });

    // Action breakdown
    const actionGroups = await prisma.auditLog.groupBy({
      by: ['action'],
      where,
      _count: true,
    });

    const actionBreakdown: Record<string, number> = {};
    actionGroups.forEach(group => {
      actionBreakdown[group.action] = group._count;
    });

    // Timeline (daily aggregation)
    const logs = await prisma.auditLog.findMany({
      where,
      select: { timestamp: true },
      orderBy: { timestamp: 'asc' },
    });

    const timeline = this.aggregateByDay(logs.map(l => l.timestamp));

    // Top actors
    const actorGroups = await prisma.auditLog.groupBy({
      by: ['actorId', 'actorEmail'],
      where,
      _count: true,
      orderBy: {
        _count: {
          actorId: 'desc',
        },
      },
      take: 10,
    });

    const topActors = actorGroups.map(group => ({
      actorId: group.actorId,
      actorEmail: group.actorEmail,
      count: group._count,
    }));

    return {
      totalLogs,
      uniqueActors: uniqueActors.length,
      actionBreakdown,
      timeline,
      topActors,
    };
  }

  /**
   * Archive old logs (for GDPR/compliance)
   */
  async archiveLogs(olderThan: Date): Promise<number> {
    // In production, this would export to cold storage (S3, Glacier)
    // before deletion. For now, just mark as archived.
    
    // This is a placeholder - in real implementation:
    // 1. Export logs to S3/Glacier
    // 2. Verify export integrity
    // 3. Delete from hot database
    // 4. Keep reference record with archive location

    const count = await prisma.auditLog.count({
      where: {
        timestamp: {
          lt: olderThan,
        },
      },
    });

    // TODO: Implement actual archival
    console.log(`Would archive ${count} logs older than ${olderThan}`);

    return count;
  }

  // ============================================
  // PRIVATE HELPER METHODS
  // ============================================

  /**
   * Calculate changes between old and new data
   */
  private calculateChanges(
    oldData: Record<string, unknown>,
    newData: Record<string, unknown>
  ): ChangeSet {
    const changes: ChangeSet = {
      old: {},
      new: {},
    };

    // Find changed fields
    const allKeys = new Set([
      ...Object.keys(oldData),
      ...Object.keys(newData),
    ]);

    for (const key of allKeys) {
      // Skip sensitive fields
      if (this.isSensitiveField(key)) {
        continue;
      }

      const oldValue = oldData[key];
      const newValue = newData[key];

      // Deep comparison (handles objects and arrays)
      if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
        changes.old[key] = oldValue;
        changes.new[key] = newValue;
      }
    }

    return changes;
  }

  /**
   * Check if field is sensitive (should not be logged)
   */
  private isSensitiveField(fieldName: string): boolean {
    const sensitiveFields = [
      'password',
      'passwordHash',
      'token',
      'secret',
      'apiKey',
      'privateKey',
    ];

    return sensitiveFields.some(sensitive =>
      fieldName.toLowerCase().includes(sensitive.toLowerCase())
    );
  }

  /**
   * Calculate SHA-256 checksum for audit entry
   */
  private calculateChecksum(entry: Omit<AuditLogEntry, 'id' | 'checksum'>): string {
    // Create deterministic string representation
    const data = JSON.stringify({
      timestamp: entry.timestamp.toISOString(),
      actorId: entry.actorId,
      action: entry.action,
      entityType: entry.entityType,
      entityId: entry.entityId,
      changes: entry.changes,
    }, Object.keys({
      timestamp: null,
      actorId: null,
      action: null,
      entityType: null,
      entityId: null,
      changes: null,
    }).sort()); // Sort keys for deterministic output

    return createHash('sha256').update(data).digest('hex');
  }

  /**
   * Aggregate timestamps by day
   */
  private aggregateByDay(timestamps: Date[]): Array<{ date: string; count: number }> {
    const dayMap = new Map<string, number>();

    for (const timestamp of timestamps) {
      const dateKey = timestamp.toISOString().split('T')[0];
      dayMap.set(dateKey, (dayMap.get(dateKey) || 0) + 1);
    }

    return Array.from(dayMap.entries())
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }
}

// ============================================
// AUDIT DECORATOR (for automatic logging)
// ============================================

/**
 * Decorator to automatically log method calls
 * Usage: @AuditLog('CREATE', 'INVOICE')
 */
export function AuditLog(action: AuditAction, entityType?: EntityType) {
  return function (
    _target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const result = await originalMethod.apply(this, args);

      // Log after successful execution
      try {
        const context = args[0]; // Assume first arg has context
        if (context?.userId && context?.userEmail) {
          await auditLogger.log({
            actorId: context.userId,
            actorEmail: context.userEmail,
            action,
            entityType,
            entityId: result?.id,
            metadata: {
              method: propertyKey,
              args: args.slice(1), // Skip context
            },
          });
        }
      } catch (error) {
        console.error('Audit logging failed:', error);
      }

      return result;
    };

    return descriptor;
  };
}

// Export singleton instance
export const auditLogger = new AuditLoggerService();
